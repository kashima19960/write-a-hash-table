# 哈希函数

在本节中，我们将编写我们的哈希函数。

我们选择的哈希函数应满足以下条件：

- 接受一个字符串作为输入，并返回一个介于 `0` 和 `m` 之间的数字，其中 `m` 是我们期望的桶数组长度。
- 对于平均的输入集，返回均匀分布的桶索引。如果我们的哈希函数分布不均匀，它将把更多的项放入某些桶中，而不是其他桶。这将导致更高的[碰撞](#pathological-data)率。碰撞会降低哈希表的效率。

## 算法

我们将使用一个通用的字符串哈希函数，以下是用伪代码表示的算法。

```
function hash(string, a, num_buckets):
    hash = 0
    string_len = length(string)
    for i = 0, 1, ..., string_len:
        hash += (a ** (string_len - (i+1))) * char_code(string[i])
    hash = hash % num_buckets
    return hash
```

这个哈希函数有两个步骤：

1. 将字符串转换为一个大整数
2. 通过取余数 `mod` `m` 将该整数的大小缩小到固定范围

变量 `a` 应该是一个大于字母表大小的质数。我们正在对 ASCII 字符串进行哈希处理，ASCII 的字母表大小为 128，因此我们应该选择一个大于 128 的质数。

`char_code` 是一个返回表示字符的整数的函数。我们将使用 ASCII 字符码来实现这一点。

让我们尝试一下这个哈希函数：

```
hash("cat", 151, 53)

hash = (151**2 * 99 + 151**1 * 97 + 151**0 * 116) % 53
hash = (2257299 + 14647 + 116) % 53
hash = (2272062) % 53
hash = 5
```

改变 `a` 的值会给我们一个不同的哈希函数。

```
hash("cat", 163, 53) = 3
```

## 实现

```c
// hash_table.c
static int ht_hash(const char* s, const int a, const int m) {
    long hash = 0;
    const int len_s = strlen(s);
    for (int i = 0; i < len_s; i++) {
        hash += (long)pow(a, len_s - (i+1)) * s[i];
        hash = hash % m;
    }
    return (int)hash;
}
```

## 病态数据

理想的哈希函数总是返回均匀分布。然而，对于任何哈希函数，都存在一个“病态”输入集，这些输入都会哈希到相同的值。要找到这个输入集，可以将大量输入通过该函数运行。所有哈希到特定桶的输入形成一个病态集。

病态输入集的存在意味着没有适用于所有输入的完美哈希函数。我们所能做的是创建一个在预期数据集上表现良好的函数。

病态输入也带来了安全问题。如果哈希表被某个恶意用户输入一组碰撞的键，那么对这些键的搜索将比正常情况下花费更长的时间（`O(n)` 而不是 `O(1)`）。这可以用作对基于哈希表的系统（如 DNS 和某些 Web 服务）的拒绝服务攻击。

下一节：[处理碰撞](../04-collisions/README_ZH.md)